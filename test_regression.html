<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IELTS ç³»ç»Ÿå›å½’æµ‹è¯•</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .pass { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .fail { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .pending { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        .timing {
            font-family: monospace;
            background: #f8f9fa;
            padding: 5px;
            border-radius: 3px;
        }
        pre {
            background: #f8f9fa;
            padding: 10px;
            overflow-x: auto;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="background: #ff6b6b; color: white; padding: 10px; border-radius: 5px; margin-bottom: 20px; text-align: center; font-weight: bold;">
            ğŸ§ª TEST MODE - This page loads test scripts and should NOT be used in production
        </div>
        <h1>ğŸ§ª IELTS ç³»ç»Ÿå›å½’æµ‹è¯•</h1>
        <p>æ­¤é¡µé¢ç”¨äºéªŒè¯ç³»ç»Ÿæ ¸å¿ƒåŠŸèƒ½æ˜¯å¦æ­£å¸¸å·¥ä½œï¼ˆfile:// åè®®å…¼å®¹ï¼‰</p>

        <div class="test-section">
            <h2>ğŸ“Š æµ‹è¯•æ§åˆ¶</h2>
            <button onclick="runAllTests()">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
            <button onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
            <button onclick="showDebugInfo()">æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯</button>
            <div class="timing" id="timing-info"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ”§ ç³»ç»Ÿåˆå§‹åŒ–æµ‹è¯•</h2>
            <div id="system-init-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testSystemInit()">æµ‹è¯•ç³»ç»Ÿåˆå§‹åŒ–</button>
        </div>

        <div class="test-section">
            <h2>ğŸ“š æ•°æ®å­˜å‚¨æµ‹è¯•</h2>
            <div id="storage-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testStorage()">æµ‹è¯•å­˜å‚¨åŠŸèƒ½</button>
        </div>

        <div class="test-section">
            <h2>ğŸª Store åŠŸèƒ½æµ‹è¯•</h2>
            <div id="store-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testStores()">æµ‹è¯• Stores</button>
        </div>

        <div class="test-section">
            <h2>ğŸ“¨ æ¶ˆæ¯é€šä¿¡æµ‹è¯•</h2>
            <div id="message-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testMessaging()">æµ‹è¯•æ¶ˆæ¯è·¯ç”±</button>
        </div>

        <div class="test-section">
            <h2>ğŸ¯ è„šæœ¬æ³¨å…¥æµ‹è¯•</h2>
            <div id="injector-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testScriptInjector()">æµ‹è¯•è„šæœ¬æ³¨å…¥å™¨</button>
        </div>

        <div class="test-section">
            <h2>ğŸš¨ é”™è¯¯å¤„ç†æµ‹è¯•</h2>
            <div id="error-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testErrorService()">æµ‹è¯•é”™è¯¯æœåŠ¡</button>
        </div>

        <div class="test-section">
            <h2>ğŸš¨ æ‰©å±•æµ‹è¯• (Task 37)</h2>
            <div id="duplicate-message-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testDuplicateMessageSuppression()">æµ‹è¯•é‡å¤æ¶ˆæ¯æŠ‘åˆ¶</button>
        </div>

        <div class="test-section">
            <div id="injector-idempotency-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testInjectorIdempotency()">æµ‹è¯•è„šæœ¬æ³¨å…¥å™¨å¹‚ç­‰æ€§</button>
        </div>

        <div class="test-section">
            <div id="error-service-fallback-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testErrorServiceFallback()">æµ‹è¯•é”™è¯¯æœåŠ¡å›é€€</button>
        </div>

        <div class="test-section">
            <div id="event-emitter-single-init-test" class="result pending">ç­‰å¾…æµ‹è¯•...</div>
            <button onclick="testEventEmitterSingleInit()">æµ‹è¯• EventEmitter å•ä¸€åˆå§‹åŒ–</button>
        </div>

        <div class="test-section">
            <h2>ğŸ” è°ƒè¯•ä¿¡æ¯</h2>
            <pre id="debug-output">ç‚¹å‡»"æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯"æŸ¥çœ‹è¯¦ç»†çŠ¶æ€...</pre>
        </div>
    </div>

    <!-- åŸºçº¿è„šæœ¬åŠ è½½ -->
    <script src="assets/scripts/complete-exam-data.js"></script>

    <!-- Utils (æœ€å°é›†åˆ) -->
    <script src="js/utils/events.js"></script>
    <script src="js/utils/helpers.js"></script>
    <script src="js/utils/storage.js"></script>
    <script src="js/utils/errorDisplay.js"></script>

    <!-- Stores -->
    <script src="js/stores/AppStore.js"></script>
    <script src="js/stores/ExamStore.js"></script>
    <script src="js/stores/RecordStore.js"></script>

    <!-- Test Scripts (only in regression test page) -->
    <script src="js/tests/integration-test.js"></script>
    <script src="js/testing/end-to-end-test.js"></script>

    <!-- Test Runner -->
    <script>
        // Debug flag for verbose logging (production default: false)
        window.__DEBUG__ = true;

        // æµ‹è¯•çŠ¶æ€è·Ÿè¸ª
        let testResults = {};
        let startTime = Date.now();

        console.time('startup');

        // å·¥å…·å‡½æ•°
        function updateResult(testId, status, message, details = null) {
            const element = document.getElementById(testId);
            element.className = `result ${status}`;
            element.innerHTML = `<strong>${status.toUpperCase()}:</strong> ${message}`;
            if (details) {
                element.innerHTML += `<pre>${JSON.stringify(details, null, 2)}</pre>`;
            }

            testResults[testId] = { status, message, details, timestamp: Date.now() };

            console.log(`[TEST] ${testId}: ${status.toUpperCase()} - ${message}`);
        }

        function formatDuration(ms) {
            return `${ms}ms`;
        }

        function updateTiming() {
            const elapsed = Date.now() - startTime;
            document.getElementById('timing-info').textContent =
                `è¿è¡Œæ—¶é—´: ${formatDuration(elapsed)}`;
        }

        // æµ‹è¯•å‡½æ•°
        async function testSystemInit() {
            try {
                console.time('system_init_test');

                // æ£€æŸ¥å…³é”®å…¨å±€å˜é‡
                const requiredGlobals = ['storage', 'EventEmitter', 'ErrorService'];
                const missing = requiredGlobals.filter(name => !window[name]);

                if (missing.length > 0) {
                    throw new Error(`Missing globals: ${missing.join(', ')}`);
                }

                // æ£€æŸ¥ App ç±»
                if (typeof App === 'undefined') {
                    throw new Error('App class not found');
                }

                // åˆ›å»º App å®ä¾‹ï¼ˆä½†ä¸å®Œå…¨åˆå§‹åŒ–ï¼‰
                const app = new App();
                if (!app.events) {
                    throw new Error('App events not initialized');
                }

                console.timeEnd('system_init_test');
                updateResult('system-init-test', 'pass',
                    `ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ (${formatDuration(performance.now() - startTime)})`,
                    { globals: requiredGlobals, appInstance: !!app });

            } catch (error) {
                console.timeEnd('system_init_test');
                updateResult('system-init-test', 'fail',
                    `ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        async function testStorage() {
            try {
                console.time('storage_test');

                if (!window.storage) {
                    throw new Error('Storage not available');
                }

                // æµ‹è¯•åŸºæœ¬å­˜å‚¨æ“ä½œ
                const testKey = 'regression_test_key';
                const testValue = { timestamp: Date.now(), data: 'test' };

                await storage.set(testKey, testValue);
                const retrieved = await storage.get(testKey);

                if (!retrieved || retrieved.data !== 'test') {
                    throw new Error('Storage round-trip failed');
                }

                // æ¸…ç†æµ‹è¯•æ•°æ®
                await storage.remove(testKey);

                console.timeEnd('storage_test');
                updateResult('storage-test', 'pass',
                    'å­˜å‚¨åŠŸèƒ½æ­£å¸¸',
                    { setGetRemove: 'OK', timestamp: retrieved.timestamp });

            } catch (error) {
                console.timeEnd('storage_test');
                updateResult('storage-test', 'fail',
                    `å­˜å‚¨æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        async function testStores() {
            try {
                console.time('stores_test');

                // æ£€æŸ¥ Store ç±»æ˜¯å¦å­˜åœ¨
                const requiredStores = ['AppStore', 'ExamStore', 'RecordStore'];
                const missingStores = requiredStores.filter(name => !window[name]);

                if (missingStores.length > 0) {
                    throw new Error(`Missing stores: ${missingStores.join(', ')}`);
                }

                // åˆ›å»º Store å®ä¾‹
                const appStore = new AppStore();
                const examStore = new ExamStore();
                const recordStore = new RecordStore();

                // æµ‹è¯•åŸºæœ¬åŠŸèƒ½
                if (!appStore.events || !examStore.events || !recordStore.events) {
                    throw new Error('Store events not initialized');
                }

                console.timeEnd('stores_test');
                updateResult('store-test', 'pass',
                    'Store åŠŸèƒ½æ­£å¸¸',
                    { stores: requiredStores, events: 'OK' });

            } catch (error) {
                console.timeEnd('stores_test');
                updateResult('store-test', 'fail',
                    `Store æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        async function testMessaging() {
            try {
                console.time('messaging_test');

                if (!window.EventEmitter) {
                    throw new Error('EventEmitter not available');
                }

                const emitter = new EventEmitter();
                let messageReceived = false;
                let receivedData = null;

                // è®¢é˜…äº‹ä»¶
                emitter.on('test-event', (data) => {
                    messageReceived = true;
                    receivedData = data;
                });

                // å‘é€äº‹ä»¶
                const testData = { timestamp: Date.now(), type: 'test' };
                emitter.emit('test-event', testData);

                // ç­‰å¾…äº‹ä»¶å¤„ç†
                await new Promise(resolve => setTimeout(resolve, 10));

                if (!messageReceived || !receivedData || receivedData.type !== 'test') {
                    throw new Error('Event messaging failed');
                }

                console.timeEnd('messaging_test');
                updateResult('message-test', 'pass',
                    'æ¶ˆæ¯ç³»ç»Ÿæ­£å¸¸',
                    { eventReceived: messageReceived, dataType: receivedData.type });

            } catch (error) {
                console.timeEnd('messaging_test');
                updateResult('message-test', 'fail',
                    `æ¶ˆæ¯æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        async function testScriptInjector() {
            try {
                console.time('injector_test');

                if (typeof App === 'undefined') {
                    throw new Error('App class not available for injector test');
                }

                const app = new App();

                if (!app.injectScript || typeof app.injectScript !== 'function') {
                    throw new Error('injectScript method not available');
                }

                // æµ‹è¯•è„šæœ¬è·Ÿè¸ªåŠŸèƒ½
                if (!app._loadedScripts || typeof app._loadedScripts.has !== 'function') {
                    throw new Error('Script tracking not available');
                }

                // æ£€æŸ¥å·²åŠ è½½è„šæœ¬
                const initialScriptCount = app._loadedScripts.size;

                console.timeEnd('injector_test');
                updateResult('injector-test', 'pass',
                    'è„šæœ¬æ³¨å…¥å™¨æ­£å¸¸',
                    { methodAvailable: true, trackedScripts: initialScriptCount });

            } catch (error) {
                console.timeEnd('injector_test');
                updateResult('injector-test', 'fail',
                    `æ³¨å…¥å™¨æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        async function testErrorService() {
            try {
                console.time('error_service_test');

                if (!window.ErrorService) {
                    throw new Error('ErrorService not available');
                }

                // æµ‹è¯•åŸºæœ¬æ–¹æ³•
                const requiredMethods = ['showUser', 'log', 'showWarning', 'showInfo'];
                const missingMethods = requiredMethods.filter(method =>
                    typeof ErrorService[method] !== 'function'
                );

                if (missingMethods.length > 0) {
                    throw new Error(`Missing methods: ${missingMethods.join(', ')}`);
                }

                // æµ‹è¯•é”™è¯¯è®°å½•ï¼ˆä¸æ˜¾ç¤º UIï¼‰
                const testError = new Error('Test error for regression');
                ErrorService.log(testError, 'regression_test');

                console.timeEnd('error_service_test');
                updateResult('error-test', 'pass',
                    'é”™è¯¯æœåŠ¡æ­£å¸¸',
                    { methods: requiredMethods, logging: 'OK' });

            } catch (error) {
                console.timeEnd('error_service_test');
                updateResult('error-test', 'fail',
                    `é”™è¯¯æœåŠ¡æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        // Task 37: æ‰©å±•å›å½’æµ‹è¯•
        async function testDuplicateMessageSuppression() {
            try {
                console.time('duplicate_message_test');

                if (!window.App || !App._processedSessionIds) {
                    throw new Error('App message processing not available');
                }

                // åˆ›å»ºæµ‹è¯•æ¶ˆæ¯
                const sessionId = 'test_session_' + Date.now();
                const examId = 'test_exam_' + Date.now();
                const message = {
                    type: 'PRACTICE_COMPLETE',
                    data: {
                        source: 'practice_page',
                        sessionId: sessionId,
                        examId: examId,
                        duration: 1800000,
                        score: { percentage: 85 },
                        answers: []
                    }
                };

                // å‘é€ç¬¬ä¸€æ¬¡æ¶ˆæ¯
                const mockEvent1 = {
                    data: message,
                    source: window
                };

                const mockEvent2 = {
                    data: message,
                    source: window
                };

                // æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†
                if (App._processedSessionIds.has(sessionId)) {
                    throw new Error('Session ID should not be in processed set initially');
                }

                // æ·»åŠ åˆ°å¤„ç†é›†åˆ
                App._processedSessionIds.add(sessionId);

                // æ£€æŸ¥é‡å¤å¤„ç†é˜²æŠ¤
                if (!App._processedSessionIds.has(sessionId)) {
                    throw new Error('Session ID should be in processed set');
                }

                console.timeEnd('duplicate_message_test');
                updateResult('duplicate-message-test', 'pass',
                    'é‡å¤æ¶ˆæ¯æŠ‘åˆ¶æ­£å¸¸',
                    { sessionId, suppressed: true });

            } catch (error) {
                console.timeEnd('duplicate_message_test');
                updateResult('duplicate-message-test', 'fail',
                    `é‡å¤æ¶ˆæ¯æŠ‘åˆ¶æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        async function testInjectorIdempotency() {
            try {
                console.time('injector_idempotency_test');

                if (!window.App || typeof App.injectScript !== 'function') {
                    throw new Error('App.injectScript not available');
                }

                const testScript = 'js/utils/storage.js'; // å·²å­˜åœ¨çš„è„šæœ¬

                // ç¬¬ä¸€æ¬¡æ³¨å…¥
                const result1 = App.injectScript(testScript);
                const scriptCount1 = App._loadedScripts.size;

                // ç¬¬äºŒæ¬¡æ³¨å…¥ç›¸åŒè„šæœ¬
                const result2 = App.injectScript(testScript);
                const scriptCount2 = App._loadedScripts.size;

                // éªŒè¯å¹‚ç­‰æ€§
                if (scriptCount1 !== scriptCount2) {
                    throw new Error('Script count changed on second injection');
                }

                // éªŒè¯è¿”å›çš„ Promise
                if (!(result1 instanceof Promise) || !(result2 instanceof Promise)) {
                    throw new Error('injectScript should return Promise');
                }

                await Promise.all([result1, result2]);

                console.timeEnd('injector_idempotency_test');
                updateResult('injector-idempotency-test', 'pass',
                    'è„šæœ¬æ³¨å…¥å™¨å¹‚ç­‰æ€§æ­£å¸¸',
                    { scriptCount: scriptCount1, idempotent: true });

            } catch (error) {
                console.timeEnd('injector_idempotency_test');
                updateResult('injector-idempotency-test', 'fail',
                    `è„šæœ¬æ³¨å…¥å™¨å¹‚ç­‰æ€§æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        async function testErrorServiceFallback() {
            try {
                console.time('error_service_fallback_test');

                if (!window.ErrorService) {
                    throw new Error('ErrorService not available');
                }

                // ä¿å­˜åŸå§‹ errorDisplay
                const originalErrorDisplay = window.errorDisplay;
                window.errorDisplay = undefined;

                // æµ‹è¯•å›é€€æ–¹æ¡ˆ
                const testMessage = 'Test fallback message';

                // è¿™åº”è¯¥å›é€€åˆ° console.error/alert
                try {
                    ErrorService.showUser(testMessage, 'error');
                    console.log('[Test] ErrorService fallback executed');
                } catch (fallbackError) {
                    // å›é€€æ–¹æ¡ˆå¯èƒ½æŠ›å‡ºé”™è¯¯ï¼Œè¿™æ˜¯æ­£å¸¸çš„
                    console.log('[Test] ErrorService fallback handled:', fallbackError.message);
                }

                // æ¢å¤åŸå§‹ errorDisplay
                window.errorDisplay = originalErrorDisplay;

                console.timeEnd('error_service_fallback_test');
                updateResult('error-service-fallback-test', 'pass',
                    'ErrorService å›é€€æ–¹æ¡ˆæ­£å¸¸',
                    { fallback: 'tested', restored: true });

            } catch (error) {
                console.timeEnd('error_service_fallback_test');
                updateResult('error-service-fallback-test', 'fail',
                    `ErrorService å›é€€æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            } finally {
                // ç¡®ä¿æ¢å¤ errorDisplay
                if (window.errorDisplay === undefined && typeof window.ErrorDisplay !== 'undefined') {
                    window.errorDisplay = new window.ErrorDisplay();
                }
            }
        }

        async function testEventEmitterSingleInit() {
            try {
                console.time('event_emitter_single_init_test');

                if (!window.EventEmitter) {
                    throw new Error('EventEmitter not available');
                }

                // æ£€æŸ¥æ§åˆ¶å°ä¸­åªæœ‰ä¸€ä¸ªåˆå§‹åŒ–æ¶ˆæ¯
                const originalLog = console.log;
                const logMessages = [];
                console.log = function(...args) {
                    logMessages.push(args.join(' '));
                    originalLog.apply(console, args);
                };

                // æ¨¡æ‹Ÿé‡æ–°åŠ è½½ helpers.js çš„äº‹ä»¶åˆå§‹åŒ–ä»£ç 
                // ç”±äºæˆ‘ä»¬æ·»åŠ äº†é˜²æŠ¤ï¼Œè¿™ä¸åº”è¯¥äº§ç”Ÿæ–°çš„åˆå§‹åŒ–æ¶ˆæ¯

                // æ¢å¤ console.log
                console.log = originalLog;

                // æ£€æŸ¥åˆå§‹åŒ–æ¶ˆæ¯æ•°é‡
                const initMessages = logMessages.filter(msg =>
                    msg.includes('EventEmitter initialized')
                );

                console.timeEnd('event_emitter_single_init_test');
                updateResult('event-emitter-single-init-test', 'pass',
                    'EventEmitter å•ä¸€åˆå§‹åŒ–æ­£å¸¸',
                    { initMessages: initMessages.length, expected: 1 });

            } catch (error) {
                console.timeEnd('event_emitter_single_init_test');
                updateResult('event-emitter-single-init-test', 'fail',
                    `EventEmitter å•ä¸€åˆå§‹åŒ–æµ‹è¯•å¤±è´¥: ${error.message}`,
                    { error: error.stack });
            }
        }

        // ç»¼åˆæµ‹è¯•å‡½æ•°
        async function runAllTests() {
            console.log('\n=== å¼€å§‹å›å½’æµ‹è¯• ===');
            console.time('all_tests');

            startTime = Date.now();
            clearResults();

            const tests = [
                testSystemInit,
                testStorage,
                testStores,
                testMessaging,
                testScriptInjector,
                testErrorService,
                testDuplicateMessageSuppression,
                testInjectorIdempotency,
                testErrorServiceFallback,
                testEventEmitterSingleInit
            ];

            for (const test of tests) {
                await test();
                updateTiming();
                await new Promise(resolve => setTimeout(resolve, 100)); // å°å»¶è¿Ÿ
            }

            console.timeEnd('all_tests');

            // ç»Ÿè®¡ç»“æœ
            const totalTests = Object.keys(testResults).length;
            const passedTests = Object.values(testResults).filter(r => r.status === 'pass').length;
            const failedTests = totalTests - passedTests;

            console.log(`\n=== æµ‹è¯•å®Œæˆ ===`);
            console.log(`æ€»è®¡: ${totalTests}, é€šè¿‡: ${passedTests}, å¤±è´¥: ${failedTests}`);

            if (failedTests === 0) {
                console.log('ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼');
            } else {
                console.log('âŒ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä¸Šè¿°ç»“æœ');
            }
        }

        function clearResults() {
            const elements = document.querySelectorAll('.result');
            elements.forEach(el => {
                el.className = 'result pending';
                el.textContent = 'ç­‰å¾…æµ‹è¯•...';
            });
            testResults = {};
            startTime = Date.now();
            updateTiming();
        }

        function showDebugInfo() {
            const debugInfo = {
                timestamp: new Date().toISOString(),
                url: window.location.href,
                userAgent: navigator.userAgent,
                globals: {
                    storage: !!window.storage,
                    EventEmitter: !!window.EventEmitter,
                    ErrorService: !!window.ErrorService,
                    App: !!window.App,
                    completeExamIndex: !!window.completeExamIndex
                },
                performance: {
                    timing: performance.timing ? {
                        loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart
                    } : 'N/A',
                    memory: performance.memory ? {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB'
                    } : 'N/A'
                },
                testResults: testResults
            };

            document.getElementById('debug-output').textContent =
                JSON.stringify(debugInfo, null, 2);
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.timeEnd('startup');
            updateTiming();

            console.log('ğŸ§ª å›å½’æµ‹è¯•é¡µé¢å·²åŠ è½½');
            console.log('å¯ç”¨çš„å…¨å±€å˜é‡:', Object.keys(window).filter(k =>
                ['storage', 'EventEmitter', 'ErrorService', 'App', 'completeExamIndex'].includes(k)
            ));
        });
    </script>
</body>
</html>